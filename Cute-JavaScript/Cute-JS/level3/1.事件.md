本文是 **重温基础** 系列文章的第二十篇。
今日感受：电影有时候看的是缘分。   

**本章节复习的是JS中的事件，事件冒泡捕获代理等等。**          

**前置知识：**   
JavaScript与HTML的交互式通过**事件**来实现的，是文档或浏览器窗口中发生的一些特定的交互瞬间。   

## 1.事件流
事件流描述的是从页面中接收事件的顺序，通常有这样两种完全相反的事件流概念：**事件冒泡流**（IE团队提出）和**事件捕获流**（网景团队提出）。   

### 1.1 事件冒泡
冒泡事件（Event Bubbling）：事件开始时由最具体的元素接收（文档中嵌套层次最深的那个节点），然后逐层向上传播到较为不具体的节点（文档），看下示例代码：    
```html
<!DOCTYPE html>
<html>
<head>
    <title>leo 事件冒泡</title>
</head>
<body>
    <div id="leo">点击</div>
</body>
</html>
```
点击页面中`<div>`元素，这个`click`事件就会按照下面顺序传播：   
1. `<div> `   
2. `<body>`   
3. `<html> `   
4. `document`   

由此可见，元素绑定的事件会通过DOM树向上传播，每层节点都会发生，直到`document对象`，如图展示了冒泡过程：   
![事件冒泡流](http://images.pingan8787.com/20190127%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E6%B5%81.png)   

### 1.2 事件捕获
事件捕获（Event Capturing）：让不太具体的节点更早接收事件，而最具体的节点最后接收事件，即在事件到达预定目标之前捕获到，看下示例代码（HTML代码和前面一样），事件捕获的过程是这样的：   
1. `document`   
2. `<html> `   
3. `<body>`   
4. `<div> `   

看得出，`document对象`最新接收事件，然后沿DOM树依次向下，直到最后的实际目标`<div>`元素，如图展示了捕获过程：   

![事件捕获流](http://images.pingan8787.com/20190127%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E6%B5%81.png)   

注意：由于老版本的浏览器不支持，因此很少人使用事件捕获，不过如果特殊需求还是可以使用事件捕获，建议还是使用事件冒泡。    

### 1.3 DOM事件流
“DOM2级事件”规定的事件流包含三个阶段：**事件捕获阶段**，**处于目标阶段**和**事件冒泡阶段**。    
事件捕获为截获事件提供机会，然后实际的目标接收到事件，最后事件冒泡，对事件作出响应。按照前面的HTML代码，整个流程是这样的：   

![DOM事件流](http://images.pingan8787.com/20190127DOM%E4%BA%8B%E4%BB%B6%E6%B5%81.png)   

在DOM事件流中，实际目标（`<div>`元素）在捕获阶段不接收事件，即在捕获阶段，事件从`document对象`到`<html>`再到`<body>`后就停止，进入“处于目标”阶段，事件在`<div>`元素上发生，然后才进入冒泡阶段，将事件传回给文档。   

注意：目前主流浏览器都支持DOM事件流，只有IE8和之前版本不支持。    


## 2.事件处理
事件处理，即响应某个事件。我们把事件处理的函数，称为“事件处理程序”。    
事件处理程序的名称一般都以`on`开头，如`click`事件的事件处理程序就是`onclick`，`load`事件的事件处理程序就是`onload`。  
我们将事件处理程序，分为这么几类：    
* HTML事件处理程序   
* DOM0级事件处理程序    
* DOM2级事件处理程序   
* IE事件处理程序   
* 跨浏览器事件处理程序   

### 2.1 HTML事件处理程序
某个元素支持的事件，都可以用一个与相应事件处理程序同名的HTML特性来指定，这个特性的值应该是能够执行的JavaScript代码。比如：    
```html
<input type="button" value="点击" onclick="alert('hello leo');">
```
也可以把需要执行的具体事件单独定义出来，可以放置与单独`.js`文件，也可以在文档内用`<script>`标签引入：    
```js
function fun(){
    alert('hello leo');
}
```
```html
<input type="button" value="点击" onclick="fun()">
```
我们通过这样指定事件处理程序，可以有一个局部变量`event`来获取事件对象本身，在这个函数内部，`this`值等于这个变量`event`。  
```html
<input type="button" value="点击" onclick="fun(event)">
``` 

另外，HTML中指定事件处理程序，会有2个缺点：   
1. 存在时间差  
可能出现这样的情况：HTML元素触发事件，但是事件处理程序还未定义（函数的定义在HTML最底下定义），就会出现报错，这与HTML代码加载顺序有关。    
2. 作用域链的异常
由于不同浏览器JavaScript引擎遵循的标识符解析规则存在差异，导致访问非限定对象成员时出错，表现为事件处理程序的作用域链在不同浏览器结果不同。
3. HTML和JavaScript代码紧密耦合
这常常就是很多开发人员放弃HTML事件处理程序的原因。   

### 2.2 DOM0级事件处理程序
通过赋值形式，将一个函数赋值给一个事件处理程序属性。每个元素（包含`window`和`document`）都有自己的事件处理属性，这些属性通常全部小写，如`onclick`，将这种属性的值设置成一个函数，就可以指定事件处理程序：   
```js
var leo = document.getElementById('leo');
leo.onclick = function(){
    alert('hello leo!');
}
```
使用**DOM0级**方法指定事件处理程序，被认为是元素的方法。此时的事件处理程序是在元素的作用域执行，那么，this就引用当前元素，可以访问元素的任何属性和方法：    
```js
var leo = document.getElementById('leo');
leo.onclick = function(){
    alert(this.id);  // "leo"
}
```
我们也可以通过设置事件处理程序属性来删除**DOM0级**的事件处理程序。   
```js
leo.onclick = null;
```

### 2.3 DOM2级事件处理程序
有2个方法：   
* 添加事件处理程序：`addEventListener()`      
* 删除事件处理程序：`removeEventListener()`   

所有的DOM节点都包含这两个方法，并且它们都接收三个参数：   
* 处理的事件名称   
* 事件处理程序的函数   
* 布尔值（true：事件捕获阶段调用，false：事件冒泡阶段调用） 

```js
var leo = document.getElementById('leo');
leo.addEventListener('click',function(){
    alert(this.id);        // "leo"
},false);
```
与DOM0级方法一样，这里的事件处理程序也会是在元素的作用域中执行，因此this也是指向元素，可以访问元素的任何属性和方法。   

使用DOM2级方法，可以添加多个事件处理程序，并**按照添加顺序触发**：   
```js
var leo = document.getElementById('leo');
leo.addEventListener('click',function(){
    alert(this.id);       // "leo"
},false);
leo.addEventListener('click',function(){
    alert('hello leo!');  // "hello leo!"
},false);
```

**注意**：通过`addEventListener()`添加的事件只能通过`removeEventListener()`移除，并且两者传入的参数一致，这就意味着通过`addEventListener()`添加的匿名函数不能被移除，看下面代码：   
```js
var leo = document.getElementById('leo');
leo.addEventListener('click',function(){
    alert(this.id);       // "leo"
},false);

// 没有效果
leo.removeEventListener('click',function(){
    // do some thing
},false);
```
没有效果是因为这两个方法传入的函数，是完全不同的，为了达到删除事件处理程序的效果，我们可以将处理函数单独定义出来：   
```js
var leo = document.getElementById('leo');
var fun = function(){
    alert(this.id);
}
leo.addEventListener('click',fun,false);
// 有效果
leo.removeEventListener('click',fun,false);
```

### 2.4 IE事件处理程序
IE实现两种方法： `attachEvent()`和`detachEvent()`。这两个方法接收相同的两个参数：**事件处理程序名称**和**事件处理程序函数**。    
由于IE8和更早版本只支持事件冒泡，所以通过`attachEvent()`添加的事件处理程序会被添加到冒泡阶段。   
```js
var leo = document.getElementById('leo');
leo.attachEvent('onclick',function(){
    alert('hello leo');       // "leo"
},false);
// attachEvent也支持添加多个事件处理程序

leo.attachEvent('onclick',function(){
    alert('hello world');       // "leo"
},false);
```
**注意**：这里的第一个参数是`onclick`而不是DOM的`addEventListener()`的`click`。   

**IE的attachEvent()和DOM0级方法区别**：   
两者事件处理程序的作用域不同。   
* DOM0级方法，作用域在所属元素的作用域。   
* attachEvent()，作用域在全局作用域，即`this`指向`window`。   

和DOM0级方法一样，`detachEvent()`只能移除使用`attachEvent()`添加的方法，为了避免无法移除，也是需要将处理的函数单独定义出来：    
```js
var leo = document.getElementById('leo');
var fun = function(){
    alert(this.id);
}
leo.attachEvent('onclick',fun,false);
// 有效果
leo.detachEvent('onclick',fun,false);
```

### 2.6 跨浏览器事件处理程序
在做跨浏览器事件处理程序，我们可以有两种方式：   
1. 使用能够隔离浏览器差异的JavaScript库   
2. 单独手写一个处理方法

我们单独受写一个处理方法也不难，只需关注好事件冒泡阶段，我们可以创建一个方法，区分使用**DOM0级方法**、**DOM2级方法**或**IE方法**即可，默认采用**DOM0级方法**。   
```js
var my_event = {
    addMyEvent:function(element, type, handler){
        if(element.addEventListener){
            element.addEventListener(type, handler, false);
        }else if(element.attachEvent){
            element.attachEvent('on' + type, handler);
        }else{
            element['on' + type] = handler;
        }
    };
    removeMyEvent:function(element, type, handler){
        if(element.removeEventListener){
            element.removeEventListener(type, handler, false);
        }else if(element.detachEvent){
            element.detachEvent('on' + type, handler);
        }else{
            element['on' + type] = null;
        }
    }
}

```

## 3.事件对象
当触发一个DOM上的事件时，都会产生一个事件对象`event`，并作为参数传入事件处理程序，这个对象包含所有与事件相关的信息。包括导致事件的元素、事件类型等其他信息。   

### 3.1 DOM中的事件对象
无论指定事件处理程序时使用am方法（DOM0级方法或DOM2级方法），都会传入`event`对象：   
```js
var leo = document.getElementById('leo');
leo.onclick = function(event){
    alert(event.type);  // 'click'
}
leo.addEventListener('click',function(event){
    alert(event.type);  // 'click'
},false);
```
`event`对象包含与创建它的特定事件相关的属性和方法，常常有如下成员：   
![event成员1](http://images.pingan8787.com/20190127%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%981.png)   

![event成员2](http://images.pingan8787.com/20190127%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%982.png)   


## 4.事件类型

## 5.事件委托

## 6.事件模拟


## 参考文章：  
1. [MDN 闭包](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures#%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F)    
2. 《JavaScript高级程序设计》第13章 事件    


**本部分内容到这结束**

|Author|王平安|
|---|---|
|E-mail|pingan8787@qq.com|
|博  客|www.pingan8787.com|
|微  信|pingan8787|
|每日文章推荐|https://github.com/pingan8787/Leo_Reading/issues|
|JS小册|js.pingan8787.com|
