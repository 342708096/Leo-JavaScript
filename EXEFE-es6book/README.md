**整理进度**：
- [x] 介绍
- [x] 目录
- [ ] ES6
- [ ] ES7
- [ ] ES8
- [ ] ES9
- [ ] 知识补充
> 最后更新 2018.10.17

# 一、介绍
现如今网络上已经有各式各样关于 **ECMAScript** 规范的介绍和分析的文章，而我准备整理一份比较完善也比较精简便于快速入门的资料。
这份资料的**ES6部分**将会参考阮一峰老师的 [ECMAScript6入门](http://es6.ruanyifeng.com/) ，精简和整理出快速实用的内容。
另外**ES7/ES8/ES9**则会从网络参考和整理。

# 二、目录
<!-- TOC -->

- [一、介绍](#一介绍)
- [二、目录](#二目录)
- [三、正文](#三正文)
    - [1. ES6](#1-es6)
        - [let 和 const命令](#let-和-const命令)
        - [变量的解构赋值](#变量的解构赋值)
        - [字符串的拓展](#字符串的拓展)
        - [正则的拓展](#正则的拓展)
        - [数值的拓展](#数值的拓展)
        - [函数的拓展](#函数的拓展)
        - [对象的拓展](#对象的拓展)
    - [2. ES7](#2-es7)
    - [3. ES8](#3-es8)
    - [4. ES9](#4-es9)
    - [5. 知识补充](#5-知识补充)
        - [块级作用域](#块级作用域)
- [四、结语](#四结语)

<!-- /TOC -->

# 三、正文
## 1. ES6

### let 和 const命令
在ES6中，我们通常实用 `let` 表示**变量**，`const` 表示**常量**，并且 `let` 和 `const` 都是**块级作用域**，且在当前作用域有效不能重复声明。
* **不存在变量提升：**
在ES6之前，我们 `var` 声明一个**变量**一个**函数**，都会伴随着变量提升的问题，导致实际开发过程经常出现一些逻辑上的疑惑，按照一般思维习惯，变量都是需要先声明后使用。
```js
// var 
console.log(v1); // undefined
var v1 = 2;
// 由于变量提升 代码实际如下
var v1;
console.log(v1)
v1 = 2;

// let 
console.log(v2); // ReferenceError
let v2 = 2;
```

* **不允许重复声明：**
`let` 和 `const` 在相同作用域下，都**不能重复声明同一变量**，并且**不能在函数内重新声明参数**。
```js
// 1. 不能重复声明同一变量
// 报错
function f1 (){
    let a = 1;
    var a = 2;
}
// 报错
function f2 (){
    let a = 1;
    let a = 2;
}

// 2. 不能在函数内重新声明参数
// 报错
function f3 (a1){
    let a1; 
}
// 不报错
function f4 (a2){
    {
        let a2
    }
}
```


### 变量的解构赋值
### 字符串的拓展
### 正则的拓展
### 数值的拓展
### 函数的拓展
### 对象的拓展

## 2. ES7

## 3. ES8

## 4. ES9

## 5. 知识补充
### 块级作用域

通常指一个**函数内部**，或者一个**代码块内部**。  
比如：  
```js
function fun1 () {
    // 块级作用域
    if (true) {
        // 块级作用域
    }
}
```
**缺点**：
1.导致内层变量覆盖外层变量
```js
var a1 = new Date();
function f1 (){
    console.log(a1); // undefined
    if (false) {
        var a1 = 'hello'
    }
}
```
输出 `undefined` 是因为 `if` 内的 `a1` 变量声明的变量提升，导致内部的 `a1` 覆盖外部的 `a1`，所以输出为 `undefined` 。 

2.变量的全局污染
```js
var a = 'hello';
for (var i = 0; i< a.length; i++) {
    //...
}
console.log(i); // 5
```
循环结束后，变量 `i` 的值依然存在，造成变量的全局污染。


# 四、结语