>参考文章：[点击打开](http://www.cnblogs.com/janneystory/p/5689747.html)

### 1、介绍
  这里先了解下 `作用域` 在了解 `声明提前` 会好点。

### 2、变量的作用域
  在函数之外声明的变量，称为 `全局变量`，它所处的作用域就叫 `全局作用域` ，因为它可以被文档任何其他代码所访问。  
  在函数内部声明的变量，称为 `局部变量`，它所处的作用域就叫 `局部作用域` ，因为它只能在该函数内部被访问。
```
// 全局变量
let a = 'hello';       
function test1 (){
    console.log(a);    // 'hello'
    let b = 3;
} 
// 局部变量
console.log(b);        // b is undefined
```
注意：
> `局部变量` 的优先级高于 `同名的全局变量` 。
> 如果在函数 `test1()` 中声明一个局部变量也为 `a` ，则全局变量就会被局部变量覆盖;

### 3、作用域和声明提前
  在Java和C等编程语言中，在花括号 `{}` 内的代码都是有各自的作用域的，并且在这个范围以外，这些变量是不可见的，我们称这种作用域为 `块级作用域` 。  
但在javascript不适用，因为javascript没有块级作用域，但是javascript有 `函数作用域` 。  
`函数作用域` 简言之就是：`变量在声明他们的函数体以及这个函数体嵌套的任意函数体内都是有定义的` 。  
延伸理解：变量在声明之前就已经可用。我们称这种特性为 `声明提前` ，也就是函数里的所有变量都被 `提前` 至函数体的顶部。
```
var v = "yoyo"; 
(function(){ 
    console.log(v); 
    var v = "check now"; 
    console.log(v); 
})(); 
// undefined
// check now 
```
 对于第二次执行结果 `check now` 没有什么特别的，但是为什么第一次不输出 `yoyo` 而是 `undefined`。  
 对于这个问题的解释就用到上面的那句话， `局部变量在整个函数体始终是有定义的` ，即在函数体内局部变量覆盖了同名全局变量，而且，程序只有在执行到 `var语句` 时，局部变量才会被 `真正赋值` 。所以，这时你大概会明白为什么是undefined了，因为此时还没有遇到var，即没有定义，等价于下面的形式：   
 ```
var v = "yoyo"; 
(function(){ 
    var scope; 
    console.log(v); 
    var v = "check now"; 
    console.log(v); 
})(); 
 
// 将上面的代码稍稍修改为： 
var v = "yoyo"; 
(function(){ 
    console.log(v); 
})(); 
 ```
 相比于上面的代码只是少了一行添加一个局部变量 `v` 并赋值的语句，但是结果却是 `yoyo` 。  
  这里之所以输出 `yoyo` ，不能按照上面的定式思维。上面有句话叫 `局部变量在整个函数体始终是有定义的` ，但是这里没有局部变量的定义，所以按照下面要提到的作用域链会逐层向上寻找变量，最后找到了全局变量 `v` ，从而最后的输出是 `yoyo` 。  

举一个通俗点的例子，你准备要花钱买点东西时，会先摸摸自己的钱包，没了你可以找你爸要，你爸也没有就再找你爷爷，... 。而你爸没钱买东西时，他并不会来找你要。  

### 4、作用域链
  `全局变量` 在程序中始终是有定义的，`局部变量` 在声明它的函数体内以及其所嵌套的函数内始终是有定义的。  
  每一段Javascript代码（全局代码或函数）都有一个与之相关联的作用域链，这个作用域链就是 `一个对象列表或链表`。  
  比如当 Javascript需要查找变量x的值时，它会从链中的第一个对象开始，如果该对象有一个名为x的属性，则直接使用，如果不存在名为x的属性，则会继续 向链上的下一个对象查找，如此递归下去直到找到。如果整个链上都找不到，则认为不存在x这个属性。举例：  
```
var name="lwy"; 
function t(){ 
    var name="tlwy"; 
    function s(){ 
        var name="slwy"; 
        console.log(name);     // 1
    } 
    function ss(){ 
        console.log(name);     // 2
    } 
    s();   
    ss();  
}  
t(); 
```
1.输出 `name` 时，这是会在函数 `s` 内查找变量 `name` 是否存在，查找发现了局部变量 `name`，所以直接输出"slwy"；  
2.输出 `name` 时，同样会在函数 `ss` 内查找变量 `name` 是否存在，查找到并不存在变量，所以就向作用域链的上一级即这里的 `t` 函数中查找，查找发现有定义 `name="slwy"`，所以最终输出为 `"slwy"`；