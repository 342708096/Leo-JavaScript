## 文章目录
[一、开发介绍](#一开发介绍)

* [1.开发背景](#1开发背景)
* [2.工具文档](#2工具文档)

[二、开发环境搭建](#二开发环境搭建)

* [1.Nodejs环境搭建](#1nodejs环境搭建)
* [2.Python环境搭建](#2python环境搭建)

[三、开发过程](#三开发过程)

* [1.最终效果](#1最终效果)
* [2.Nodejs开发部分](#2nodejs开发部分)
* [3.Python开发部分](#3python开发部分)
* [4.运行结果展示](#4运行结果展示)

[四、知识点总结](#四知识点总结)

* [1.开发流程](#1开发流程)
* [2.Nodejs知识点](#2nodejs知识点)
* [3.Python知识点](#3python知识点)

## 一、开发介绍
> 作者：leo    
> 更新：2019.03.11    

### 1.开发背景

由于 **V2项目** 需要做组件化升级，但因为 **V2项目** 代码和文件非常多，而且嵌套较多，难以全面了解所需要调整的组件的影响范围，所以需要开发这么一个工具，来实现以下几个功能：   

* 需要能支持 **自定义关键词检索** ，便于按不同的已有组件名搜索；
* 需要能支持检索出该组件的 **影响文件范围** ，还有 **页面名称路由** 等，便于测试按照页面快速测试；
* 需要能支持 **数据可视化** ，便于判断所有影响范围的权重；
* 需要能 **导出影响范围的路由文件** 和 **必要数据** ；

基于上面需求，我大概整理思路使用 `Nodejs` 和 `Python` 进行需求开发，原因有这几点：    

* 需求以操作文件为主，包括读写；
* 需求对数据处理操作比较多，包括过滤，组装数据格式；
* 需求对数据可视化的需求；

起初我准备只使用 `Nodejs` 完成这个需求，后面开发到一半，发现 **数据可视化** 方面，实在找不到一个满意的可视化插件，于是想到 `Python` 的一个2D绘图库—— `Matplotlib` ，使用起来非常方便，于是便选择了它。   

### 2.工具文档

* [Nodejs-官方文档](https://nodejs.org/zh-cn/docs/)
* [Python-官方文档](https://docs.python.org/3/)
* [Python-中文开发手册](http://www.iteedu.com/plang/python/pythoncnshc/index.php)
* [Matplotlib-开发教程](https://www.matplotlib.org.cn/index.html)


## 二、开发环境搭建
### 1.Nodejs环境搭建
对于 `Nodejs` 环境搭建，相信对于我们前端开发仔来说，应该是很简单，但这里考虑到可能原生的同学还不太清楚，这里我简单介绍：   

* 下载和安装 `Nodejs`    

我们到[ Nodejs官网 ](https://nodejs.org/zh-cn/download/)，选择对应系统环境进行下载，然后直接打开安装。    

* 测试 `Nodejs` 环境

打开命令行工具，执行 `node -v` ，看是是否输出对应 `Nodejs` 版本号，我这显示：   
```bash
v10.8.0
```
如返回错误，如下情况，则需要将 `nodejs` 安装目录，添加全局路径：   
```bash
node : 无法将“node”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次。
```

* 安装完成

### 2.Python环境搭建

* 下载和安装 `Python`    

在[ Python官网 ](https://www.python.org/downloads/)，选择 **3.x** 版本下载（由于Python2.x版本已经停止维护，并且即将被淘汰），下载完成直接安装。     

* 测试 `Python` 环境

安装完成，打开命令行工具，执行`python`，看看输出结果是否是版本号和**命令行交互模式**，我这显示：   

```bash
PS C:\Users\mi> python

Python 3.6.3 |Anaconda, Inc.| (default, Oct 15 2017, 03:27:45) [MSC v.1900 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>
```

* 安装绘图库 `Matplotlib` 
`python` 安装其他包是用 `pip install packageName` 来安装，跟 `Nodejs` 中的 `npm install packageName` 是一样的，我们就这么安装 `Matplotlib` ：    
```bash
pip install Matplotlib
```

* 安装完成

## 三、开发过程

### 1.最终效果

最终我实现的效果是，开发 `search_current_file.js` 和 `search_current_file_python.py` 两个文件，并通过执行两个命令，来获取对应数据文件：   

* 获取 **所有包含关键词的文件的路径**、**所在文件夹内文件数量**和**所有文件对应页面的路由/参数/标题等数据** 统计的文件和表格。   
```bash
node search_current_file.js
```

![20190311share3](http://images.pingan8787.com/20190311share3.png)


* 获取 **所有文件夹中文件数量占总文件数的比例** 的饼图结果。   
```bash
python search_current_file_python.py
```
这里需要输入需要生成的指定文件夹的数据，默认不输入则生成所有文件夹下的数据。

![20190311share2](http://images.pingan8787.com/20190311share2.png)


### 2.Nodejs开发部分
首先定义几个下面主要使用的变量，其他没有写在这里的变量和作用，可以查看源码。  

```js
var filterFile = ['.html'];  // 需要检索的文件类型
var filterDir  = ['lib'];    // 需要排除的文件夹
var classArray = [           // 需要检索的类名数组
    'search-holder','exe-bar-search','输入搜索内容','<exe-search','learn-search','ion-android-search'
];  
var resultArray    = [];     // 最终结果
var resultAlassify = {};     // 最终结果分类
var excelFileArr   = [];     // excel文件内容数组
```

#### 2.1获取搜索结果 
**目的**： 搜索包含关键词的所有HTML文件，并保存这些数据。

* 核心方法 `getCurrenAllFile()`

我们通过 `fs.readdir` 方法，来获取路径下所有文件和文件夹名称作为一个集合；   
然后遍历该集合，当 `stat.isDirectory()` 为 `true` 则表示该结果**为一个文件夹**，为 `false` 则继续使用 `getCurrenAllFile()` 来读取下一层的文件信息。   
```js
/**
 * 获取当前项目的所有HTML文件
 * @param {string} paths 文件的路径
 */
var getCurrenAllFile = function (paths){
    // ... 省略部分
    var fileArr = [];// 初始化最终结果分类的对象
    fs.readdir(paths, function(err, files){
        files.forEach(function(item, index){
            var c_path = path.join(paths, item);
            var stat = fs.lstatSync(c_path);
            // TODO 关键
            if(stat && stat.isDirectory()){
                // .. 省略过滤文件夹的操作
                getCurrenAllFile(c_path);
                }
            }else{
                // .. 省略过滤文件夹的操作
                getCurrentFile(c_path, item);
            }
        });
    });
    return fileArr;
}
```

* 核心方法 `getCurrentFile()`

```js
/**
 * 获取当前文件内容
 * @param {string} paths    文件的路径
 * @param {string} filename 文件名
 */
var getCurrentFile = function(paths, filename){
    fs.readFile(paths, 'utf8', function(err, data){
        // ... 省略部分
        if (err) console.log(err);
        searchCurrentFile(data, paths);
    });
};
```

* 核心方法 `searchCurrentFile()`
```js
/**
 * 检索当前文件内容
 * @param {object} data  文件的内容
 * @param {string} paths 文件的路径
 */
var searchCurrentFile = function(data, paths){
    for(var k in classArray){
        // ... 省略部分
        if(data.indexOf(classArray[k]) >= 0){
            resultArray.push(paths);
            resultAlassify[classArray[k]].push(paths); // 保存最终结果（当前管字词下的对象）
        }
    }
};
```

#### 2.2处理搜索结果 
**目的**： 将获取到的数据，去重，格式化并保存成JSON，作为可视化的数据源。
这里有定义两个简单方法`unique()`用于数据去重，和`setEachDirFileNum()`统计文件数量，不做具体介绍。  

这个步骤中，我们使用`saveDataToJson()`将数据整理成JSON格式，并使用`setJSONFile()`方法，将JSON数据保存为`json`文件，用于可视化操作。   

* 核心方法 `saveDataToJson()`
```js
/**
 * 转成JSON数据，用来数据可视化
 * @param {*} data  需要处理的数据
 */
var saveDataToJson = function (data){
    var result = {};
    // 第一层分组
    result = _.groupBy(data, function(item){
        item = item.replace(filePath+'\\','');
        var list = item.split('\\');
        return list[0];
    });
    // 第二层分组
    for(var k in result){
        result[k] = _.groupBy(result[k], function(i){
            i = i.replace(filePath+'\\','');
            var r = i.split('\\');
            return r[1];
        });
    }
    for(var i in result){
        for(var m in result[i]){
            for(var n in result[i][m]){
                var currentPath = result[i][m][n].replace(filePath+'\\','');
                currentPath = currentPath.replace(/\\/g, '/');
                var current = excelFileObj[currentPath];
                result[i][m][n] = {
                    title : current ? current['路由名称'] : '该文件为模块',
                    path  : current ? current['文件路径'] : currentPath,
                    url   : current ? current['url'] : '该文件为模块',
                    params: current ? current['路由参数'] : '该文件为模块',
                    ctrl  : current ? current['控制器名称'] : '该文件为模块',
                    urls  : current ? current['url'] : '该文件为模块',
                };
            }
        }
    }
    setJSONFile(result);         // 保存JSON文件
    // setEachDirFileNum(result);   // 计算每个子文件夹下文件数量
};
```

* 核心方法 `setJSONFile()`
```js
/**
 * 保存JSON文件
 * @param {object} data  需要处理的数据
 */
var setJSONFile = function (data){
    data = JSON.stringify(data);
    fs.writeFile(saveJSONName , data, 'utf8' , function(err){
        if(err) console.log(err);
        console.log(saveJSONName + ' JSON文件保存成功！');
    })
};
```

#### 2.3加入文件标题路由等数据
**目的**： 解析外部路由Excel表，合并到原有数据

* 核心方法 `getExcelFile()`
```js
/**
 * 读取Excel数据
 * get excelReadName
 */
var getExcelFile = function(){
    return new Promise(function(resolve, reject){
        var excelPath = path.join(__dirname, excelReadName);
        fs.exists(excelPath, function(exists){
            if(exists){
                var workbook = XLSX.readFile(excelPath, {type: 'base64'});// 获取 Excel 中所有表名
                var sheetNames = workbook.SheetNames;
                resolve({workbook: workbook, sheetNames: sheetNames});
            }else{
                reject({message:'错误提示：请先获取路由列表文件！（执行node get_router.js）'});
            }
        });
    })
};
```

* 核心方法 `getEachSheet()`
```js
/**
 * 解析Excel数据
 * @param {object} workbook    excel工作区数据
 * @param {object} sheetNames  excel工作表名数据
 */
var getEachSheet = function(workbook, sheetNames){
    _.forEach(sheetNames,function(item,index){
        var sheet = workbook.Sheets[sheetNames[index]];
        var json = XLSX.utils.sheet_to_json(sheet);  // 针对单个表，返回序列化json数据
        excelFileArr = excelFileArr.concat(json);    // 不能使用lodash的_.concat 因为lodash版本太低
    })
    for(var k in excelFileArr){
        excelFileObj[excelFileArr[k]['文件路径']] = excelFileArr[k];
    }
}
```

#### 2.4生成结果文件
**目的**： 将处理后的结果生成对应的 Excel/JSON/TXT 文件：   
这里生成 JSON/TXT 文件不做介绍，使用的是 Nodejs 内置的文件存储方法`fs.write`

* 核心方法 `setExcelFile()`
```js
/**
 * 保存Excel数据
 * @param {object} data  需要处理的数据
 * return excelFileName.xlsx
 */
var setExcelFile = function(data){
    var workbook = new Excel.Workbook();
    workbook.creator = 'EXE';
    workbook.lastModifiedBy = 'Leo';
    workbook.created = new Date();
    workbook.modified = new Date();
    workbook.lastPrinted = new Date();
    for(var item in data){    // 第一层循环 外层文件夹 templates views
        for(var list in data[item]){
            var worksheet = workbook.addWorksheet(list.toUpperCase());
            worksheet.columns = [
                { header: '页面标题', key: 'title',  width: 40 },
                { header: '文件路径', key: 'path',   width: 60 },
                { header: '路由地址', key: 'url',    width: 40 },
                { header: '路由参数', key: 'params', width: 40 },
                { header: '控制器名称', key: 'ctrl', width: 40 },
                { header: 'url',     key: 'urls',   width: 40 },
            ];
            var rowData = data[item][list];
            for(var row in rowData){
                worksheet.addRow({
                    title : rowData[row].title,
                    path  : rowData[row].path,
                    url   : rowData[row].url,
                    params: rowData[row].params,
                    ctrl  : rowData[row].ctrl,
                    urls  : rowData[row].urls,
                }) 
            }
        }

    }

    workbook.xlsx.writeFile(path.join(__dirname, excelFileName))
        .then(function() {
            console.log(excelFileName + ' 文件生成成功');
            console.log('下一步生成饼图，请执行（python search_current_file_python.py）');
        });
};
```

### 3.Python开发部分

#### 2.1读取数据源
搜索包含关键词的所有HTML文件，并保存这些数据。

#### 2.2设置命令行输入项
将获取到的数据，去重格式化，并保存成JSON，作为可视化的数据源。

#### 2.3绘制单张饼图
解析外部路由Excel表，合并到原有数据

#### 2.4绘制多张饼图
Excel/JSON/TXT


* 核心方法 `getKeyName`

* 核心方法 `drawOneChart`

* 核心方法 `drawAllChart`

### 4.运行结果展示

## 四、知识点总结

### 1.开发流程

### 2.Nodejs知识点

### 3.Python知识点
